[TOC]
# 模块化

## 1、介绍

在平常开发的过程中，所有的这些代码都是被一个个的模块构成的，我们可以在npm上拉下我们需要的包，然后组装在我们的项目中，就好像组装模块一样，随着mvvm框架的普及，主流的开发方式都变成了模块化。在之前，js模块化还是通过命名空间来实现的，再后来产生了一个模块化规范（CommonJs），CommonJs是诞生于node社区，但它只能在服务端运行，在浏览器端还是用不了，于是，社区便出了AMD规范，国内又出了CMD，后来又出了UMD，其实这三个规范都是为了帮助模块化开发。目前比较流行的是ES6 Module规范。

### commonJS

commonjs规范的特点：

- **一个文件即一个模块**。文件中定义的变量、函数、类都是私有的，外界无法访问模块内的内容
- **通过module.exports暴露模块内的常量、函数、文件、模块等**
- **使用require引入模块**
- **同步执行**：因为commonjs是运行在nodejs服务端的，对服务端来说require()是本地加载

然后可以看一下commonjs规范的代码

```js
var foo = require('./foo') // 引入模块
var foo = require('event').some // 引入模块的某个属性

function fn() {
  console.log('fn')
}
exports = module.exports = fn // 将fn函数暴露出去
```

### AMD（Async Module Definition ）

AMD是异步模块定义，比较著名的一个库是RequireJS,它的特点：

- **使用define定义模块**
- **使用require引入模块**
- **依赖前置，提前执行**

然后可以看一下commonjs规范的代码

```js
// 会在声明并初始化要用到的所有模块，不管后续是否用到
define(
 // 模块名
 "demo",
  // 依赖
  ["a", "b"],
  function(a, b) {
    console.log(a)
  }
)
```

### CMD

CMD是通用模块定义，比较著名的一个库是玉伯大佬的SeaJS,它的特点：

- **一个文件为一个模块**
- **使用define定义模块**
- **使用require引入模块**
- **尽可能的懒执行**

AMD和CMD其实很多地方相似，但是它们最大区别是执行方式的不同，在执行过程中，经过AMD编译后，所有require引入的模块都被前置了，但是CMD虽然也会将require的代码下载下来，但是它不会去执行，直到代码运行到那个模块的依赖才会去执行对应模块的代码。

```js
define(function (require, export, module)) {
  // 通过require引入依赖
  var foo = require('./foo')
  const NUM = 2
  // 通过export或者通过module.exports暴露接口
  exports.num = NUM
  // module.exports.num = NUM
}
```

### UMD

在webpack打包过程中就有UMD这个选项，UMD其实是一个通用解决方案，在模块定义中，它主要做了三件事

- **先判断是否支持AMD**
- **然后判断是否支持CommonJs**
- **如果都不是，则定义为全局变量**

```js
(function (root, fac) {
  if (typeof define === 'function' && define.amd) { // 如果define这个方法被定义，且define.amd是否存在，说明是AMD
    define([], fac) // 以AMD的规范去定义模块
  } else if (typeof exports === 'object'){ // exports为一个对象，这个就是判断是否在node环境中，满足Commonjs规范
    module.exports = fac() // 以commonjs的规范去暴露接口
  } else {
    root.some = fac() // 暴露给浏览器的全局环境，root其实就是window
  }
})
```

### ESM（ES6 Module）

- **一个文件为一个模块**
- **使用export暴露模块内的常量、函数、文件、模块等**
- **使用import引入模块**

```js
// 暴露接口
export const NUM = 12 // 暴露常量NUM
function fn() {
  console.log('fn')
}
export { fn }
export default class myClass {...} // 默认暴露

// 引入模块
import myClass, { fn, NUM } from 'other_module'
```

> 目前webpack支持AMD（requireJS）、ES6 Modules（官方推荐）、CommonJS

## 2、理解exports、module.exports（CommonJs规范）

> `require`: node 和 es6 都支持的引入
> `export / import` : 只有es6 支持的导出引入
> `module.exports / exports`: 只有 node 支持的导出

commonjs是通过module.exports来暴露对象，那exports是什么？exports和module.exports区别又是什么？



node为每个文件都创建一个module对象，初始值为空对象{}，该对象有exports属性（即module.exports），这个属性是**对外的接口**，当通过**require加载某个文件时，其实就是加载该文件的module.exports**。下面代码通过module.exports输出变量el和函数fn1。

```js
// foo1.js
const el = 5
const fn1 = function (val) {
  return `val: ${val}`
}
module.exports.el = el
module.exports.fn1 = fn1
```

```js
// index.js
var foo1 = require('./foo1') // 加载模块

console.log(foo1) // { a: 5, fn1: [Function: fn1] }
console.log(foo1.el) // 5
console.log(foo1.fn1(4)) // val: 4
```

前面说了，require加载某个文件时，其实就是加载该文件的module.exports，那exports对象是什么？我们经常看到模块头部有这样的写法：

```js
var exports = module.exports // module.exports默认为{}
// 等价于：
module.exports = {}
exports = module.exports
```

为了方便，Node为每个模块提供一个exports对象，上面这条语句，是让exports对象指向module.exports。如此一来，exports和module.exports都指向同一块内存区域，这样我们就可以直接在exports对象上添加变量、函数、类等，以表示对外输出的接口，如同添加在module.exports一样：

```js
// foo1.js
const el = 5
const fn1 = function (val) {
  return `val: ${val}`
}
// 与module.exports上方写法相同效果
exports.el = el
exports.fn1 = fn1
```

> 但是需要注意的是，不能直接将exports变量指向一个值(直接被覆盖取值 例如：export = xxx)，因为这样等于切断了exports与module.exports的联系；也不能修改module.exports值，这样也会让exports切断联系

给两个例子感受下这句话的意思

```js
// index.js
var foo1 = require('./foo1');
console.log(foo1)

// fool1.js 
// eg1： 在第一次赋值之后，如果单独修改module.exports指向，export还是停留在上一次赋值的值,并且此时通过exports暴露任何变量、函数等是没有用的，因为export已经不指向module.exports了
var exports = module.exports = {a: 1}
module.exports = {a: 2} // 此时exports值为{a: 1}
const el = 5
exports.el = el // index.js输出的值：{a: 2}

// fool1.js  
// eg2：修改exports值，同样导致export断开与module.exports的联系
var exports = module.exports
const el = 5
exports = {} // export指向新的对象
exports.el = el // index.js输出的值：{}，因为module.exports默认是{}
```

从上面可以看出，require永远只会导出module.exports的内容，export就好似一个代驾，当断开与module.exports的联系，他就没用了，它的作用就是方便用户使用module.exports这个对象的,

如果有人不禁发问，既然是引用关系，为啥修改exports不会同时修改module.exports的值？

```js
var a = {name: 'one'}
var b = a
console.log(a) // {name: 'one'}
console.log(b) // {name: 'one'}

b.name = 'two'
console.log(a) // {name: 'two'}
console.log(b) // {name: 'two'}

var b = {name: 'three'}
console.log(a) // {name: 'two'}
console.log(b) // {name: 'three'}
```

a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。**当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样**。



总结一下 exports 和 module.exports 的区别了：

- **module.exports 初始值为一个空对象 {}**
- **exports 是指向的 module.exports 的引用**
- **require()返回的值是被加载文件的module.exports**



## 3、export、export default（ES规范）

ES module是通过export和export default来暴露接口，那它们的联系和区别是什么？

先说明export和export default 的区别：

- **在一个文件或模块中，export可以有多个，export default仅有一个**

- **通过export方式导出，在导入时要加{ }，export default则不需要**

- **export可直接导出变量表达式，export default不可**

```js
// foo.js
// export导出
export const NUM1 = 1 // 直接导出
function fn () {
  console.log('res')
}
const NUM2 = 2
export { fn, NUM2 } // 间接导出

// export default导出
export default function fn1 () { // 直接导出
  console.log('res1')
}
// const NUM2 = 2
// export default NUM2 // 间接导出
// export defult const NUM2 = 2 // export default不可导出变量表达式
```

```js
// index.js
import { NUM1, fn, NUM2 } from './foo' // 导出了export
import fn1 from './foo'  // 导出了export default
// import fn1, { NUM1, fn, NUM2 } from './foo' // 等价于上面两行

import * as all from './foo' // 将export和export default暴露出的接口都用对象all表示

fn1() // res1
fn() // res
console.log(NUM1) // 1
console.log(NUM2) // 2

console.log(all.NUM) // 1
console.log(all.default) // res1 export default暴露出来的在all的default属性里
```

另外提一下，暴露的方式还有一些拓展的写法

```js
// 第二种方式:先定义，后暴露
const NUM = 12
function fn() {...}

export { NUM, fn } // 暴露上面定义的NUM变量和fn函数
export { NUM as NUM_NEW, fn as fn1 } // 以NUM_NEW代替NUM，被暴露出去；fn同理，import也要用NUM_NEW和fn1来引入

// 可以将其他模块的内容引入进来，然后再暴露出去，作一个中转站
export {foo, bar} from 'other_module' // 引入foo和bar接口，并将其暴露出去
export * from 'src/other_module' // 表示先引入other_module模块的所有接口，然后全部暴露出去
export {foo as foo1, bar} from 'other_module' // 也可以进行重命名，将foo以foo1的名字暴露出去
```



# webpack核心概念

## loader

## plugins

- 参与打包整个过程

- 打包优化和压缩

- 配置编译时的变量

- 极其灵活

  


